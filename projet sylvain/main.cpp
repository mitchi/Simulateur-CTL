#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <iostream>
#include <vector>
#include <string>
using namespace std;

#include "includes.h"

vector<state> fsm;


/*

Fonction de recherche

#1. On cherche et tag tous les états qui satisfont les variables de base.

#2. On implémente le premier niveau de CTL

#3. 2ème niveau de CTL.


Résultat = un vecteur d'états.




*/

//This utility function takes a vector of results and outputs an array for dynamic programming
//The states that accept are tagged properly according to the enum (1 = accept)
vector<int> make_dp_array_from_results(vector<int> results)
{
	vector<int> memory;
	memory.resize(fsm.size() );

	for (int i=0; i<results.size(); i++)
	{
		int state = results[i];
		memory[i] = VALID;
	}

	return memory;
}

//Retourne un vecteur avec tous les états matchés par la formule en logique propositionnelle (simple vérification de variables, comme dans l'exemple).
vector<int> matchVariables(vector<int> recherche )
{

	vector<int>resultats;
	//resultats.resize(8);
	//for (int i=0; i < resultats.size(); i++) resultats[i]=0; //Initialisation (peut etre non nécessaire?

	//On parcoure tous les états au moins une fois
	for (int i = 0; i < fsm.size(); i++)
	{
		//On check si ya un match avec la formule en logique propositionnelle (juste une comparaison de vecteurs).
		for (int j = 0; j < fsm[i].variables.size() ; j++)
		{
			//Si on cherche cette variable
			if (recherche[j] == 1) {
				//Est-elle non-presente dans cet etat? Si elle n'est pas presente, on change d'etat
				if (fsm[i].variables[j] != 1) {
					goto nonPresente;
				}
			}
		}

		//La variable est presente dans l'etat:
		resultats.push_back(i);

		//Non presente, on continue au prochain état
		nonPresente: ;

	}


	return resultats;

}

enum AF_enum
{
	AF_UNKNOWN = 0,
	AF_ACCEPT = 1,
	AF_INVALID = 2,
	AF_VISITED = 3,
};

//Recursive function
bool all_paths_finally_satisfy(int stateId, vector<int> & memory)
{
	
	if (memory[stateId] == AF_ACCEPT)
		return true;

	if (memory[stateId] == AF_INVALID)
		return false;

	if (memory[stateId] == AF_VISITED)
		return false;

	//On marque ce state comme visited, pour pas revenir 2 fois dessus avec la recursivite
	memory[stateId] = AF_VISITED;

	//Pour toutes les transitions de cet etat
	for (int i =0; i < fsm[stateId].transitions.size(); i++)
	{

		int nextState = fsm[stateId].transitions[i].destinationid;
		
		bool answer = all_paths_finally_satisfy(nextState, memory);
		if (answer == false) return false; //on sort de cette branche immédiatement si le parcours récursif trouve une réponse fausse

	}

	//Si tous les chemins ont fini par être valide, on se retrouve ici
	memory[stateId] = AF_ACCEPT;
	return true;


}



vector<int> AF(vector<int> states)
{

	vector<int> memory;
	vector<int> results;
	memory.resize(fsm.size() );

	//Let's start with the array for the DP recursive function
	//We tag our accepting states in the memory
	for (int i =0; i < states.size() ; i++) 
	{
		int state = states[i];
		memory[state] = AF_ACCEPT;
	}

	for (int i = 0; i < memory.size(); i++)
	{

		//Les states deja calculés, add aux resultats
		if (memory[i] == AF_ACCEPT) {
			results.push_back(i);
			continue;
		}

		if (memory[i] == AF_INVALID)
			continue;

		bool answer = all_paths_finally_satisfy(i, memory);

		if (answer == false)
			memory[i] = AF_INVALID;

		else if (answer == true) {
			//Add this state to the results
			results.push_back(i);
		}
	}

	return results;
}


//Cette fonction recursive prend en parametre un etat initial et trouve si les transitions partant de cet état
//satisfont toutes (x).

//Peut utiliser le même tableau global pour faire la fonction a mémoire ou alors on passe le tableau en paramètre a la fonction
//Comme ça aucun side effects...



bool all_paths_satisfy(int stateId, vector<int> & memory)
{

	memory[stateId] = 2;

	//Pour toutes les transitions de cet état
	for (int i=0; i< fsm[stateId].transitions.size(); i++)
	{
		int nextState = fsm[stateId].transitions[i].destinationid;

		//Si le prochain etat est deja calcule valide, on return true
		if (memory[nextState] == COMPLETE_VALID)
		{
			continue;
		}

		//Si le prochain état est un etat invalide OU faux d'avance, return false
		if (memory[nextState] == INVALID || memory[nextState] == COMPLETE_INVALID)
		{
			return false;
		}

		//Si le prochain état est un état déja visité, on continue a la prochaine transition
		if (memory[nextState] == VISITED)
		{
			continue;
		}

		//Si le prochain état est valide et non visité, on fait un appel récursif
		if (memory[nextState] == VALID)
		{
			bool answer = all_paths_satisfy(nextState, memory);
			if (answer == true) continue;
			if (answer == false) return false;
		}
	}

	//Si on a parcouru toutes les transitions de l'état sans atterir dans un état invalide, on peut retourner true
	return true;
}


//Cette fonction fait le travail "All paths, globally x"
//Prend en paramètre les états acceptants X. La fonction retourne en résultats les états qui valident la propriété
//All paths, globally x.
vector<int> AG(vector<int> states)
{

	vector<int> results;
	vector<int> memory;
	memory.resize(fsm.size() );

	//On crée le vecteur memory
	for (int i = 0; i < states.size(); i++)
	{
		int state = states[i];
		memory[state] = VALID;
	}

	//On itère a travers tous les états qui acceptent x.
	for (int i =0; i<states.size(); i++)
	{

		int currentState = states[i];
		bool answer = all_paths_satisfy(currentState,memory);
		
		if (answer == true) {
			results.push_back(currentState);
			memory[currentState] = COMPLETE_VALID; //3 == Complètement calculé, true
		}

		else {
			memory[currentState] = COMPLETE_INVALID; //4 == Complètement calculé, false
		}

	}

	return results;

}

extern void readStates(char * filename);
extern void readTransitions(char * filename);

int main(void)
{

	//Done
	readStates("states.txt");

	readTransitions("transitions.txt");
 
	//On veut vérifier la propriété AF AG x sur la FSM
	
	//#1 Matcher les états en fonction de la valuation des variables. Ici on cherche x.
	//Si n états et m variables, prend un temps O(n*m)
	vector<int> recherche;
	recherche.resize(3);

	recherche[0] = 1;
	recherche[1] = 0;
	recherche[2] = 0;

	vector<int> res = matchVariables(recherche);

	vector<int> result = AG(res);

	vector<int> result2 = AF(result);

	//Pour l'instant les résultats sont bons, encore quelques incertitudes par rapport a AF


	return 0;


}


